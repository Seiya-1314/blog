(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{175:function(t,r,s){t.exports=s.p+"assets/img/8.d5d5bee4.jpg"},176:function(t,r,s){t.exports=s.p+"assets/img/9.b93e7ade.jpg"},177:function(t,r,s){t.exports=s.p+"assets/img/10.452e9437.jpg"},178:function(t,r,s){t.exports=s.p+"assets/img/11.86cb7dc3.jpg"},179:function(t,r,s){t.exports=s.p+"assets/img/12.cbc8ab20.jpg"},180:function(t,r,s){t.exports=s.p+"assets/img/13.d1665043.jpg"},181:function(t,r,s){t.exports=s.p+"assets/img/14.4f63e925.jpg"},411:function(t,r,s){"use strict";s.r(r);var e=[function(){var t=this.$createElement,r=this._self._c||t;return r("h1",{attrs:{id:"链表（上）：如何实现lru缓存淘汰算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表（上）：如何实现lru缓存淘汰算法","aria-hidden":"true"}},[this._v("#")]),this._v(" 链表（上）：如何实现LRU缓存淘汰算法?")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[this._v("#")]),this._v(" 前言")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(175),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"单链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单链表","aria-hidden":"true"}},[this._v("#")]),this._v(" 单链表")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(176),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[this._v("我们习惯性地把第一个结点叫作 "),r("em",[r("strong",[this._v("头结点")])]),this._v("，把最后一个结点叫作 "),r("em",[r("strong",[this._v("尾结点")])]),this._v("。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("从图中可以看出，针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(177),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("div",{staticClass:"warning custom-block"},[r("p",{staticClass:"custom-block-title"},[this._v("注意：")]),this._v(" "),r("p",[this._v("有利就有弊，链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"循环链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环链表","aria-hidden":"true"}},[this._v("#")]),this._v(" 循环链表")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(178),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"双向链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向链表","aria-hidden":"true"}},[this._v("#")]),this._v(" 双向链表")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(179),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"双向循环链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向循环链表","aria-hidden":"true"}},[this._v("#")]),this._v(" 双向循环链表")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(180),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"链表删除操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表删除操作","aria-hidden":"true"}},[this._v("#")]),this._v(" 链表删除操作")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"场景一：删除结点中“值等于某个给定值”的结点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#场景一：删除结点中“值等于某个给定值”的结点","aria-hidden":"true"}},[this._v("#")]),this._v(" 场景一：删除结点中“值等于某个给定值”的结点")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"场景二：删除给定指针指向的结点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#场景二：删除给定指针指向的结点","aria-hidden":"true"}},[this._v("#")]),this._v(" 场景二：删除给定指针指向的结点")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"场景三：在某个指定节点插入一个节点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#场景三：在某个指定节点插入一个节点","aria-hidden":"true"}},[this._v("#")]),this._v(" 场景三：在某个指定节点插入一个节点")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"链表-vs-数组性能比拼"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表-vs-数组性能比拼","aria-hidden":"true"}},[this._v("#")]),this._v(" 链表 VS 数组性能比拼")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:s(181),alt:""}})])},function(){var t=this.$createElement,r=this._self._c||t;return r("div",{staticClass:"warning custom-block"},[r("p",{staticClass:"custom-block-title"},[this._v("注意：")]),this._v(" "),r("p",[this._v("数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。")]),this._v(" "),r("p",[this._v("数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"如何基于链表实现-lru-缓存淘汰算法？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何基于链表实现-lru-缓存淘汰算法？","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何基于链表实现 LRU 缓存淘汰算法？")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[this._v("思路是这样的："),r("strong",[this._v("我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("ol",[r("li",[r("p",[this._v("如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。")])]),this._v(" "),r("li",[r("p",[this._v("如果此数据没有在缓存链表中，又可以分为两种情况：")]),this._v(" "),r("ul",[r("li",[r("p",[this._v("如果此时缓存未满，则将此结点直接插入到链表的头部；")])]),this._v(" "),r("li",[r("p",[this._v("如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。")])])])])])}],_=s(0),i=Object(_.a)({},function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("br"),t._v(" "),s("author",{attrs:{time:"2019年08月01日"}}),t._v(" "),s("br"),t._v(" "),t._m(1),t._v(" "),s("br"),t._v(" "),s("p",[t._v("相比数组，链表是一种稍微复杂一点的数据结构。从底层的存储结构上来看，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。")]),t._v(" "),s("br"),t._v(" "),s("p",[t._v("而链表恰恰相反，它并不需要一块连续的内存空间。它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。")]),t._v(" "),t._m(2),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(3),t._v(" "),s("br"),t._v(" "),s("p",[t._v("链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next。")]),t._v(" "),t._m(4),t._v(" "),s("br"),t._v(" "),t._m(5),t._v(" "),s("br"),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),s("br"),t._v(" "),t._m(9),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(10),t._v(" "),s("br"),t._v(" "),s("p",[t._v("循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点，循环链表的尾结点指针是指向链表的头结点。")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(13),t._v(" "),s("br"),t._v(" "),s("p",[t._v("单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。")]),t._v(" "),t._m(14),t._v(" "),s("p",[t._v("从图中可以看出，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。")]),t._v(" "),s("br"),t._v(" "),t._m(15),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(16),t._v(" "),s("br"),t._v(" "),t._m(17),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(18),t._v(" "),s("br"),t._v(" "),t._m(19),t._v(" "),s("br"),t._v(" "),s("p",[t._v("不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。")]),t._v(" "),s("p",[t._v("尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。")]),t._v(" "),s("br"),t._v(" "),t._m(20),t._v(" "),s("br"),t._v(" "),s("p",[t._v("如果已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表。")]),t._v(" "),s("p",[t._v("但是对于双向链表来说，因为已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！")]),t._v(" "),s("br"),t._v(" "),t._m(21),t._v(" "),s("br"),t._v(" "),s("p",[t._v("同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。")]),t._v(" "),s("br"),t._v(" "),t._m(22),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(23),t._v(" "),s("br"),t._v(" "),t._m(24),t._v(" "),s("br"),t._v(" "),t._m(25),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),t._m(26),t._v(" "),s("br"),t._v(" "),t._m(27),t._v(" "),s("br"),t._v(" "),t._m(28)],1)},e,!1,null,null,null);r.default=i.exports}}]);