(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{188:function(t,e,r){t.exports=r.p+"assets/img/6-1.5c0ec42e.jpg"},189:function(t,e,r){t.exports=r.p+"assets/img/6-2.dea27f2c.jpg"},190:function(t,e,r){t.exports=r.p+"assets/img/6-3.c916fe22.jpg"},191:function(t,e,r){t.exports=r.p+"assets/img/6-4.58ba37bb.jpg"},192:function(t,e,r){t.exports=r.p+"assets/img/6-5.71a41eff.jpg"},193:function(t,e,r){t.exports=r.p+"assets/img/6-6.5ef33261.jpg"},414:function(t,e,r){"use strict";r.r(e);var s=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"队列：队列在线程池等有限资源池中的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#队列：队列在线程池等有限资源池中的应用","aria-hidden":"true"}},[this._v("#")]),this._v(" 队列：队列在线程池等有限资源池中的应用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"如何理解“队列”"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何理解“队列”","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何理解“队列”")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("队列跟栈一样，也是一种"),e("strong",[this._v("操作受限的线性表数据结构")]),this._v("。队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。&oq=队列最大的特点就是先进先出，主要的两个操作是入队和出队。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"“队列”的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#“队列”的实现","aria-hidden":"true"}},[this._v("#")]),this._v(" “队列”的实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"顺序队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#顺序队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 顺序队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(188),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(189),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("和数组操作类似，这里也是使用 "),e("strong",[this._v("数据搬移")]),this._v(" 的方式。同时，在入队时，若没有空闲空间了，再集中触发一次数据搬移操作，能够将时间复杂度从原来的 O(1) 变为 O(n)。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"链式队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链式队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 链式队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(190),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"循环队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#循环队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 循环队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(191),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(192),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 阻塞队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:r(193),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"并发队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发队列","aria-hidden":"true"}},[this._v("#")]),this._v(" 并发队列")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"开篇解答"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开篇解答","aria-hidden":"true"}},[this._v("#")]),this._v(" 开篇解答")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("p",[this._v("基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。")])]),this._v(" "),e("li",[e("p",[this._v("而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。"),e("strong",[this._v("实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。")])])}],a=r(0),i=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),r("br"),t._v(" "),r("author",{attrs:{time:"2019年08月06日"}}),t._v(" "),r("br"),t._v(" "),t._m(1),t._v(" "),r("br"),t._v(" "),t._m(2),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(3),t._v(" "),r("br"),t._v(" "),r("p",[t._v("队列跟栈一样，也是一种抽象的数据结构。跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。当然，队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。")]),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(4),t._v(" "),r("p",[t._v("比起栈的数组实现，队列的数组实现稍微有点儿复杂。对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。如下图所示：")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),r("br"),t._v(" "),r("p",[t._v("当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？")]),t._v(" "),t._m(7),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(8),t._v(" "),r("p",[t._v("基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示：")]),t._v(" "),t._m(9),t._v(" "),r("p",[t._v("入队时，tail->next= new_node, tail = tail->next；出队时，head = head->next。")]),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(10),t._v(" "),r("p",[t._v("循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。如下图所示：")]),t._v(" "),t._m(11),t._v(" "),r("br"),t._v(" "),r("p",[t._v("图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：")]),t._v(" "),t._m(12),t._v(" "),r("br"),t._v(" "),r("p",[t._v("通过这样的方法，我们成功避免了数据搬移操作。")]),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(13),t._v(" "),r("p",[t._v("阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。如下：")]),t._v(" "),t._m(14),t._v(" "),r("br"),t._v(" "),r("p",[t._v("这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。")]),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(15),t._v(" "),r("p",[t._v("线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。")]),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),r("br"),t._v(" "),t._m(16),t._v(" "),r("br"),t._v(" "),t._m(17),t._v(" "),r("br"),t._v(" "),r("p",[t._v("一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？")]),t._v(" "),t._m(18),t._v(" "),r("br"),t._v(" "),t._m(19)],1)},s,!1,null,null,null);e.default=i.exports}}]);