(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{580:function(t,e,_){"use strict";_.r(e);var s=_(0),r=Object(s.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),_("br"),t._v(" "),_("author",{attrs:{time:"2019年06月01日"}}),t._v(" "),_("br"),t._v(" "),t._m(1),t._v(" "),_("br"),t._v(" "),_("p",[t._v("V8 是 Google 开源的一个高性能 JavaScript 和 WebAssembly 引擎，用 C++ 编写，最开始是由一些语言方面的专家设计出来的，后被 Google 收购。")]),t._v(" "),_("p",[t._v("V8 编译并执行 JavaScript 源代码，处理对象的内存分配，同时回收不再使用的对象的内存，精确的垃圾收集器是V8性能的关键之一。它支持众多的操作系统以及众多的硬件架构，它将主流软硬件平台一网打尽，由于它是一个开源项目，开发者可以自由使用它的能力，一个例子就是目前的 NodeJs 项目。")]),t._v(" "),_("br"),t._v(" "),_("div",{staticClass:"tip custom-block"},[_("p",{staticClass:"custom-block-title"},[t._v("WebAssembly")]),t._v(" "),_("p",[t._v("一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。")]),t._v(" "),_("p",[_("strong",[t._v("参考资料：")]),t._v(" "),_("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/WebAssembly",target:"_blank",rel:"noopener noreferrer"}},[t._v("WebAssembly - MDN - Mozilla"),_("OutboundLink")],1)])]),t._v(" "),_("br"),t._v(" "),_("br"),t._v(" "),t._m(2),t._v(" "),_("br"),t._v(" "),_("p",[t._v("要了解 V8 引擎的内部工作机制，有必要先了解 V8 引擎的一些相关概念，我们可以根据官方文档上的介绍大概理解 v8 引擎的工作方式。下面来看看这些概念分别表示什么意思：")]),t._v(" "),t._m(3),t._v(" "),_("br"),t._v(" "),_("br"),t._v(" "),t._m(4),t._v(" "),_("p",[t._v("现在我们已经熟悉 V8 引擎的一些关键概念（如句柄，范围和上下文），现在进一步讨论这些概念，并介绍一些其他概念：")]),t._v(" "),_("br"),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),_("br"),t._v(" "),_("ul",[_("li",[t._m(7),t._v(" "),_("p",[t._v("其他的句柄很少被提到，所以只介绍这两种。")]),t._v(" "),_("ul",[t._m(8),t._v(" "),_("li",[t._m(9),t._v(" "),_("p",[_("font",{attrs:{color:"red"}},[_("strong",[t._v("持久句柄并不保存在堆栈中，并且仅当你专门删除它们时才会被删除。")])])],1),t._v(" "),_("p",[t._v("像本地句柄一样，持久句柄也保存指向堆分配对象的引用。如果你需要在多个函数中访问同一个对象，或者句柄的生命周期和C++作用域并不相同时，你可以使用持久句柄；")])])])])]),t._v(" "),_("br"),t._v(" "),t._m(10),t._v(" "),_("br"),t._v(" "),t._m(11),t._v(" "),_("p",[t._v("前面提到过，要执行任何 JavaScript 代码，必须显式的指定其运行的上下文。"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("V8 引擎使用上下文的初衷是，使每个窗口和浏览器的 iframe 可以有它们自己的 JavaScript 环境。")])])],1),t._v(" "),_("p",[t._v("从CPU时间和内存的角度看来，创建一个新的执行环境并建立必须的对象，可能是非常昂贵的开销。")]),t._v(" "),t._m(12),t._v(" "),_("br"),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),_("br"),t._v(" "),t._m(16),t._v(" "),_("br"),t._v(" "),t._m(17),t._v(" "),_("p",[t._v("存取器（accessors）是一个C++回调函数，在JavaScript脚本存取对象属性时计算并返回该属性的值。存取器可以通过对象模板的SetAccessor方法来设置。此方法接受一个属性名称和两个回调函数分别用于读取和写入属性的值。")]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("一个存取器的复杂程度取决于它们操作的数据类型：")]),t._v(" "),t._m(18),t._v(" "),_("br"),t._v(" "),t._m(19),t._v(" "),_("p",[t._v("我们还可以指定一个在脚本访问对象的任意属性时都会触发的回调，这些回调被称为拦截器(interceptors)。为了提高效率，V8中有两种类型的拦截器：")]),t._v(" "),t._m(20),t._v(" "),_("br"),t._v(" "),_("p",[_("font",{attrs:{color:"red"}},[_("strong",[t._v("和存取器相同，只要属性被访问，指定的回调都会被调用。存取器和拦截器之间的不同是：拦截器可以处理所有属性，但存取器只与一个特定的属性相关联。")])])],1),t._v(" "),_("br"),t._v(" "),t._m(21),t._v(" "),_("p",[t._v("在V8中“源”被定义为一个上下文。默认情况下，不能在一个作用域中访问其他作用域。要访问和当前作用域不同的作用域，你需要使用安全令牌(security token)或安全回调(security callbacks)。")]),t._v(" "),_("p",[t._v("当试图将访问一个全局变量时的V8引擎安全系统首先检查被访问全局对象的安全令牌和访问代码的安全令牌。如果令牌匹配则授予访问权限。如果不匹配V8引擎会执行一个回调，用以判定是否应该允许访问。")]),t._v(" "),t._m(22),t._v(" "),t._m(23)],1)},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"了解-v8-引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#了解-v8-引擎","aria-hidden":"true"}},[this._v("#")]),this._v(" 了解 V8 引擎")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[this._v("#")]),this._v(" 前言")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"关键概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键概念","aria-hidden":"true"}},[this._v("#")]),this._v(" 关键概念")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("code",[t._v("Isolate")]),t._v("：")]),t._v(" "),_("p",[t._v("表示 V8 引擎的一个实例，包含相关状态信息、堆等；")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("Local handle")]),t._v("：")]),t._v(" "),_("p",[t._v("表示本地句柄，它是一个指向对象的指针。所有的 V8 对象都是通过句柄进行访问，由于 V8 垃圾收集器的特殊工作方式，它是必须的；")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("Handle scope")]),t._v("：")]),t._v(" "),_("p",[t._v("一个包含任意数量的句柄容器，我们可以进行一次性的删除句柄操作，避免重复调用；")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("Context")]),t._v("：")]),t._v(" "),_("p",[t._v("表示执行上下文，它是一种执行环境。允许 JavaScript 应用单独的、不相关的 运行在 V8 引擎的实例中。而要执行任何 JavaScript 代码，我们必须明确指定其运行的上下文；")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"详细介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#详细介绍","aria-hidden":"true"}},[this._v("#")]),this._v(" 详细介绍")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_1-handles-and-garbage-collection：句柄和垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-handles-and-garbage-collection：句柄和垃圾回收","aria-hidden":"true"}},[this._v("#")]),this._v(" 1. "),e("code",[this._v("Handles and garbage collection")]),this._v("：句柄和垃圾回收")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("句柄：")])]),t._v(" "),_("p",[t._v("提供了 javascript 对象在堆中位置的引用；")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("垃圾收集器：")])]),t._v(" "),_("p",[t._v("回收不可访问对象使用的内存；")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("在垃圾回收过程中，垃圾收集器经常移动堆中对象的位置，当垃圾收集器移动一个对象时，它也会更新所有指向对象的句柄，使其指向对象的新位置；")])]),t._v(" "),_("li",[_("p",[t._v("如果一个对象在 JavaScript 代码中不可访问，且没有任何句柄指向这个对象，则该对象会被视为垃圾。垃圾收集器会不时删除所有被认为是垃圾的对象。")])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("下面介绍两种类型的句柄：")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("li",[_("p",[_("code",[t._v("Local handle")]),t._v("：本地句柄")]),t._v(" "),_("p",[t._v("本地句柄保存在堆栈(stack)上，并在其析构函数被调用时被删除。这些句柄的生命周期由句柄作用域(handle scope)决定，该作用域通常在函数调用开始时创建；")]),t._v(" "),_("p",[t._v("删除句柄作用域时，垃圾收集器可以自由释放句柄作用域中以前引用的对象，前提是这些对象不再可以从JavaScript或其他句柄访问；")]),t._v(" "),_("div",{staticClass:"warning custom-block"},[_("p",{staticClass:"custom-block-title"},[t._v("析构函数")]),t._v(" "),_("p",[t._v("析构函数 (destructor) 与构造函数相反，当对象结束其生命周期，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Persistent handle")]),this._v("：持久句柄")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("注意：")]),this._v(" "),e("p",[this._v("每创建一个对象都会创建一个句柄，这可能会导致出现大量的句柄！这时句柄作用域就非常有用了。句柄作用域的析构函数被调用时会从堆栈中删除该作用域内所有的句柄。这会使所有被删除句柄所指向的对象被垃圾回收器标记为从堆中删除。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_2-context：执行环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-context：执行环境","aria-hidden":"true"}},[this._v("#")]),this._v(" 2. "),e("code",[this._v("Context")]),this._v("：执行环境")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("必要性：")])]),t._v(" "),_("p",[t._v("因为 JavaScript 提供了一套内置的实用函数和对象，并且它们可以被 JavaScript 代码修改。而当两个完全不相干的 JavaScript 函数都以同样的方式改变了全局对象，则很可能会产生意外结果。例如一个页面 JavaScript 代码修改内置对象方法 toString，不应该影响到另外页面。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("优化：")])]),t._v(" "),_("p",[t._v("V8引擎中广泛存在的缓存特性可以保证，第一次创建上下文是比较昂贵的，但其后创建上下文的花费会少很多。")]),t._v(" "),_("p",[t._v("因为第一个上下文（context）需求创建内置对象并解析内置的 JavaScript 代码(built-in JavaScript code)，但随后创建的上下文只需要创建自己的内置对象即可。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("快照机制(Snapshot)：")])]),t._v(" "),_("p",[_("strong",[t._v("快照机制就是将这些内置的 JavaScript 对象和函数加载之后的内存保存并序列化。")]),t._v(" 通过构建参数 "),_("code",[t._v("snapshot=yes")]),t._v(" 来激活，默认处于激活状态。")]),t._v(" "),_("p",[t._v("这样第一次创建上下文所花的时间也将会被很大程度的优化。因为快照功能包含一个经过序列化的堆，其中已经包括编译好的 JavaScript 内置对象和函数的代码。与垃圾收集机制一样，V8引擎中广泛存在的缓存也是V8引擎高性能的关键。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_3-templates：模板"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-templates：模板","aria-hidden":"true"}},[this._v("#")]),this._v(" 3. "),e("code",[this._v("Templates")]),this._v("：模板")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在上下文中(Context)，模板是JavaScript函数和对象的框架。"),e("strong",[this._v("您可以使用模板将C++函数和数据结构包装在JavaScript对象中，使他们可以通过JavaScript脚本来操作。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("举个例子：Chrome使用模板将 C++ "),e("code",[this._v("DOM")]),this._v(" 节点包装成 JavaScript 对象，并将其安装在全局命名空间中。这样我们就可以通过 JavaScript 代码操作 "),e("code",[this._v("DOM")]),this._v(" 对象。下面我们介绍两种类型的模板：")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("函数模板")])]),t._v(" "),_("p",[t._v("函数模板是一个函数的框架。你可以在想要生成 JavaScript 函数的上下文中调用模板的”GetFunction”方法来创建一个该模版的 JavaScript 实例。您还可以将一个c++回调函数和一个函数模版相关联，这个回调函数将在 JavaScript 函数执行时被调用。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("对象模板")])]),t._v(" "),_("p",[t._v("每个函数模板都有一个与之关联的对象模板。它用来配置使用这个函数作为构造函数所创建的对象。对于对象模板，你可以将两种C++回调函数与之关联：")]),t._v(" "),_("ul",[_("li",[_("p",[_("code",[t._v("存取回调(accessor callbacks)")]),t._v("：在对象的指定属性被脚本访问时调用；")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("拦截回调(interceptor callbacks)")]),t._v("：在对象的任意属性被脚本访问时调用；")])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_4-accessors：存取器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-accessors：存取器","aria-hidden":"true"}},[this._v("#")]),this._v(" 4. "),e("code",[this._v("Accessors")]),this._v("：存取器")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[e("strong",[this._v("存取静态全局变量")])])]),this._v(" "),e("li",[e("p",[e("strong",[this._v("存取动态变量")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_5-interceptors：拦截器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-interceptors：拦截器","aria-hidden":"true"}},[this._v("#")]),this._v(" 5. "),e("code",[this._v("Interceptors")]),this._v("：拦截器")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[_("strong",[t._v("命名属性拦截器")]),t._v(" ：使用属性名访问属性时被调用。")]),t._v(" "),_("p",[t._v("例如，在浏览器环境中，使用document.theFormName.elementName。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("索引属性拦截器")]),t._v(" ：使用索引访问属性时被调用。")]),t._v(" "),_("p",[t._v("例如，在浏览器环境中，使用document.forms.elements[0]")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"_6-security-model：安全模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-security-model：安全模型","aria-hidden":"true"}},[this._v("#")]),this._v(" 6. "),e("code",[this._v("Security model")]),this._v("：安全模型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("安全令牌")]),this._v(" "),e("p",[this._v("一个安全令牌可以是任何值，但通常是一个符号或一个唯一的字符串。当定义上下文时，您可以通过 SetSecurityToken 指定安全令牌。如果你不指定安全令牌 V8 引擎将自动为新建的上下文生成令牌。")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"tip custom-block"},[_("p",{staticClass:"custom-block-title"},[t._v("同源规则")]),t._v(" "),_("p",[t._v("阻止从一个“源”中加载的文件或脚本获取或设置不同“源”的文档属性。这里的“源”包括 "),_("code",[t._v("域名")]),t._v("、"),_("code",[t._v("协议")]),t._v("和 "),_("code",[t._v("端口")]),t._v("，所有这三个必须匹配，才被视为同源。如果没有这种保护，恶意网页可能会影响其他正常的网页。")])])}],!1,null,null,null);e.default=r.exports}}]);