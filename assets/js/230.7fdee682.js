(window.webpackJsonp=window.webpackJsonp||[]).push([[230],{646:function(t,s,a){"use strict";a.r(s);var r=a(0),e=Object(r.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),a("br"),t._v(" "),a("author",{attrs:{time:"2019年08月27日"}}),t._v(" "),a("br"),t._v(" "),t._m(1),t._v(" "),a("br"),t._v(" "),a("p",[t._v("async 函数是什么？一句话，它就是 Generator 函数的语法糖。async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。")]),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),t._m(2),t._v(" "),a("p",[t._v("async函数对 Generator 函数的改进，体现在以下四点：")]),t._v(" "),t._m(3),t._v(" "),a("br"),t._v(" "),t._m(4),t._v(" "),a("br"),t._v(" "),t._m(5),t._v(" "),a("br"),t._v(" "),t._m(6),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),t._m(7),t._v(" "),a("br"),t._v(" "),t._m(8),t._v(" "),a("br"),t._v(" "),t._m(9),t._v(" "),a("br"),t._v(" "),t._m(10),t._v(" "),a("br"),t._v(" "),t._m(11),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),t._m(12),t._v(" "),a("br"),t._v(" "),a("p",[t._v("async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。如下所示：")]),t._v(" "),t._m(13),t._m(14),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),t._m(15),t._v(" "),a("br"),t._v(" "),a("p",[t._v("严谨的说，async 是一种语法，Promise 是一个内置对象，两者并不具备可比性，更何况 async 函数也返回一个 Promise 对象。")]),t._v(" "),a("br"),t._v(" "),a("p",[t._v("在某些场景下，使用 async 会比使用 Promise 更优雅的处理异步流程。")])],1)},[function(){var t=this.$createElement,s=this._self._c||t;return s("h1",{attrs:{id:"es6-之-async函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-之-async函数","aria-hidden":"true"}},[this._v("#")]),this._v(" ES6 之 async函数")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"async-的含义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-的含义","aria-hidden":"true"}},[this._v("#")]),this._v(" async 的含义")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"async-函数的改进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-函数的改进","aria-hidden":"true"}},[this._v("#")]),this._v(" async 函数的改进")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("内置执行器")]),this._v("：")]),this._v(" "),s("p",[this._v("Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("更好的语义")]),this._v("：")]),this._v(" "),s("p",[this._v("async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("更广的适用性")]),this._v("：")]),this._v(" "),s("p",[this._v("co 模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("返回值是 Promise")]),this._v("：")]),this._v(" "),s("p",[this._v("async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"async-的语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-的语法","aria-hidden":"true"}},[this._v("#")]),this._v(" async 的语法")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("返回 Promise 对象")]),this._v("：")]),this._v(" "),s("p",[this._v("async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。")]),this._v(" "),s("p",[this._v("async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("Promise 对象的状态变化")]),this._v("：")]),this._v(" "),s("p",[this._v("async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。")]),this._v(" "),s("p",[s("strong",[this._v("也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。")])])])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ul",[a("li",[a("p",[a("strong",[t._v("await 命令")]),t._v("：")]),t._v(" "),a("p",[t._v("正常情况下，await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。")]),t._v(" "),a("p",[t._v("另一种情况是，await 命令后面是一个 thenable 对象（即定义 then 方法的对象），那么 await 会将其等同于 Promise 对象。")]),t._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("注意：")]),t._v(" "),a("p",[t._v("任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("tips")]),t._v(" "),a("p",[t._v("有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 await 放在 try...catch 结构里面，这样不管这个异步操作是否成功，第二个 await 都会执行。")]),t._v(" "),a("p",[t._v("另一种方法是 await 后面的 Promise 对象再跟一个 catch 方法，处理前面可能出现的错误。")])])])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ul",[a("li",[a("p",[a("strong",[t._v("错误处理")]),t._v("：")]),t._v(" "),a("p",[t._v("如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。")]),t._v(" "),a("p",[a("strong",[t._v("注意点：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。")])]),t._v(" "),a("li",[a("p",[t._v("多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发（使用 Promise.all）。")])]),t._v(" "),a("li",[a("p",[t._v("await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。")])]),t._v(" "),a("li",[a("p",[t._v("async 函数可以保留运行堆栈。")])])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"async-函数的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-函数的实现原理","aria-hidden":"true"}},[this._v("#")]),this._v(" async 函数的实现原理")])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("args")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等同于")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("args")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("spawn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("strong",[this._v("所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"async-与-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-与-promise","aria-hidden":"true"}},[this._v("#")]),this._v(" async 与 Promise")])}],!1,null,null,null);s.default=e.exports}}]);