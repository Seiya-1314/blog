(window.webpackJsonp=window.webpackJsonp||[]).push([[253],{562:function(t,s,e){"use strict";e.r(s);var r=e(0),i=Object(r.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("br"),t._v(" "),e("author",{attrs:{time:"2019年06月13日"}}),t._v(" "),e("br"),t._v(" "),t._m(1),t._v(" "),e("br"),t._v(" "),e("p",[t._v("作用域是每种计算机语言最重要的基础之一，当然它也是JavaScript最重要的概念之一。")]),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(2),t._v(" "),e("br"),t._v(" "),t._m(3),t._v(" "),e("br"),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(7),t._v(" "),e("br"),t._v(" "),e("p",[t._v("要理解作用域，我们从 JavaScript 引擎的角度看看一段程序到底是怎样执行的。")]),t._v(" "),e("br"),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),e("br"),t._v(" "),t._m(11),t._v(" "),e("br"),t._v(" "),t._m(12),t._v(" "),e("p",[t._v("通俗来讲就是：当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。")]),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(13),t._v(" "),e("br"),t._v(" "),t._m(14),t._v(" "),e("br"),t._v(" "),t._m(15),t._v(" "),e("br"),t._v(" "),e("ul",[e("li",[t._m(16),t._v(" "),e("p",[e("font",{attrs:{color:"red"}},[e("strong",[t._v("词法作用域是在写代码或者说定义时确定的，关注函数在何处声明")])]),t._v(" 。")],1),t._v(" "),e("p",[t._v("词法作用域最重要的特征是它的定义过程发生在代码的书写阶段。")]),t._v(" "),e("p",[t._v("换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。")])])]),t._v(" "),e("br"),t._v(" "),e("ul",[e("li",[t._m(17),t._v(" "),e("p",[e("font",{attrs:{color:"red"}},[e("strong",[t._v("动态作用域是在运行时确定的，关注函数从何处调用")])]),t._v(" 。")],1),t._v(" "),e("p",[t._v("动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们 从何处调用 。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。")]),t._v(" "),t._m(18)])])],1)},[function(){var t=this.$createElement,s=this._self._c||t;return s("h1",{attrs:{id:"深入javascript作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深入javascript作用域","aria-hidden":"true"}},[this._v("#")]),this._v(" 深入JavaScript作用域")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[this._v("#")]),this._v(" 前言")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域","aria-hidden":"true"}},[this._v("#")]),this._v(" 作用域")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"作用域是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域是什么","aria-hidden":"true"}},[this._v("#")]),this._v(" 作用域是什么")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将 "),s("code",[this._v("状态")]),this._v(" 带给了程序。但是将变量引入程序带来了几个问题：这些变量在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为 "),s("code",[this._v("作用域")]),this._v(" 。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("作用域的简单概念")]),this._v(" "),s("p",[this._v("作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"理解作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解作用域","aria-hidden":"true"}},[this._v("#")]),this._v(" 理解作用域")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("我们有这样一段程序："),s("code",[this._v("var a = 2;")])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ol",[e("li",[e("p",[t._v("遇到 "),e("code",[t._v("var a")]),t._v(" ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 "),e("code",[t._v("a")]),t._v("。")])]),t._v(" "),e("li",[e("p",[t._v("接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 "),e("code",[t._v("a = 2")]),t._v(" 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 "),e("code",[t._v("a")]),t._v(" 的变量。 如果存在，引擎就会使用这个变量；如果不存在，引擎会继续向上查找该变量；如果没有找到，引擎就会举手示意并抛出一个异常！")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("总结：")]),this._v(" "),s("p",[this._v("变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("注意：LHS查询、RHS查询")]),this._v(" "),s("ul",[s("li",[this._v("LHS 查询则是试图找到变量的容器本身，从而可以对其赋值；")]),this._v(" "),s("li",[this._v("RHS 查询理解成retrieve his source value（取到它的源值），及得到某某的值；")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"作用域嵌套"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域嵌套","aria-hidden":"true"}},[this._v("#")]),this._v(" 作用域嵌套")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"词法作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域","aria-hidden":"true"}},[this._v("#")]),this._v(" 词法作用域")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 "),s("code",[this._v("词法作用域")]),this._v("。另外一种叫作 "),s("code",[this._v("动态作用域")]),this._v("，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"词法作用域和动态作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域和动态作用域","aria-hidden":"true"}},[this._v("#")]),this._v(" 词法作用域和动态作用域")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("strong",[this._v("词法作用域")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("strong",[this._v("动态作用域")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("注：")]),this._v(" "),s("p",[this._v("实际上动态作用域是 JavaScript 另一个重要机制 this 的表亲")])])}],!1,null,null,null);s.default=i.exports}}]);