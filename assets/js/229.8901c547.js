(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{649:function(t,s,e){"use strict";e.r(s);var r=e(0),n=Object(r.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("br"),t._v(" "),e("author",{attrs:{time:"2019年08月27日"}}),t._v(" "),e("br"),t._v(" "),t._m(1),t._v(" "),e("br"),t._v(" "),e("p",[t._v("所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。")]),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),e("br"),t._v(" "),t._m(4),t._v(" "),e("br"),t._v(" "),t._m(5),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(6),t._v(" "),e("br"),t._v(" "),t._m(7),t._v(" "),t._m(8),e("br"),t._v(" "),t._m(9),t._v(" "),e("br"),t._v(" "),t._m(10),t._v(" "),e("br"),t._v(" "),e("p",[t._v("Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。")]),t._v(" "),t._m(11),t._v(" "),t._m(12),e("br"),t._v(" "),t._m(13),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(14),t._v(" "),e("br"),t._v(" "),t._m(15),t._v(" "),e("br"),t._v(" "),t._m(16),t._v(" "),e("br"),t._v(" "),t._m(17),t._v(" "),e("br"),t._v(" "),t._m(18),t._v(" "),e("br"),t._v(" "),t._m(19),t._v(" "),e("br"),t._v(" "),t._m(20),t._v(" "),e("br"),t._v(" "),t._m(21),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),e("br"),t._v(" "),t._m(22),t._v(" "),e("br"),t._v(" "),t._m(23),t._v(" "),e("br"),t._v(" "),t._m(24),t._v(" "),e("br"),t._v(" "),t._m(25),t._v(" "),e("br"),t._v(" "),t._m(26)],1)},[function(){var t=this.$createElement,s=this._self._c||t;return s("h1",{attrs:{id:"es6-之-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-之-promise","aria-hidden":"true"}},[this._v("#")]),this._v(" ES6 之 Promise")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"promise-的含义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-的含义","aria-hidden":"true"}},[this._v("#")]),this._v(" Promise 的含义")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"promise-对象的两个特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象的两个特点","aria-hidden":"true"}},[this._v("#")]),this._v(" Promise 对象的两个特点")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[e("p",[e("strong",[t._v("对象的状态不受外界影响")])]),t._v(" "),e("p",[t._v("Promise 对象代表一个异步操作，有三种状态："),e("strong",[e("code",[t._v("pending")])]),t._v("（进行中）、"),e("strong",[e("code",[t._v("fulfilled")])]),t._v("（已成功）和 "),e("strong",[e("code",[t._v("rejected")])]),t._v("（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("一旦状态改变，就不会再变，任何时候都可以得到这个结果")])]),this._v(" "),s("p",[this._v("Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 "),s("strong",[s("code",[this._v("resolved")])]),this._v("（已定型）。")]),this._v(" "),s("p",[this._v("如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("tips")]),this._v(" "),s("p",[this._v("有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本用法","aria-hidden":"true"}},[this._v("#")]),this._v(" 基本用法")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。"),s("strong",[this._v("Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。")]),this._v(" 基本使用如下：")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" promise "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reject")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... some code")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 异步操作成功 */")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("resolve")]),this._v("：")]),this._v(" "),s("p",[this._v("resolve 函数将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("reject")])]),this._v(" "),s("p",[this._v("reject 函数将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去；")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("then")]),this._v("：")]),this._v(" "),s("p",[this._v("then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。")])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("promise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("value")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// success")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// failure")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("注意：")]),this._v(" "),s("p",[this._v("立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。所以，最好在 resolve 函数前面加上 return 语句，这样就不会有意外。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"promise-prototype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype","aria-hidden":"true"}},[this._v("#")]),this._v(" Promise.prototype")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[s("code",[this._v("Promise.prototype.then()")])]),this._v("：")]),this._v(" "),s("p",[this._v("then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法；")])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[e("p",[e("strong",[e("code",[t._v("Promise.prototype.catch()")])]),t._v("：")]),t._v(" "),e("p",[t._v("Promise.prototype.catch 方法是 .then(null, rejection) 或 .then(undefined, rejection) 的别名，用于指定发生错误时的回调函数；")]),t._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("tips")]),t._v(" "),e("p",[t._v("Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。")])]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("注意：")]),t._v(" "),e("p",[t._v("跟传统的 try/catch 代码块不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。")])])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[e("p",[e("strong",[e("code",[t._v("Promise.prototype.finally()")])]),t._v("：")]),t._v(" "),e("p",[t._v("finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的；")]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("注意：")]),t._v(" "),e("p",[t._v("finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。")])])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[e("p",[e("strong",[e("code",[t._v("Promise.all()")])]),t._v("：")]),t._v(" "),e("p",[t._v("Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例；")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("被包装的实例，只有状态都变成 fulfilled，新的实例状态才会变成 fulfilled；")])]),t._v(" "),e("li",[e("p",[t._v("只要其中一个被 rejected，新的实例状态就会变成 rejected；")])])]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("注意：")]),t._v(" "),e("p",[t._v("如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的catch方法。")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[s("code",[this._v("Promise.race()")])]),this._v("：")]),this._v(" "),s("p",[this._v("Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例；")]),this._v(" "),s("ul",[s("li",[this._v("被包装的实例，只要一个实例率先改变状态，新实例的状态就跟着改变；")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[s("code",[this._v("Promise.resolve()")])]),this._v("：")]),this._v(" "),s("p",[this._v("Promise.resolve 方法可以将现有对象转为 Promise 对象；")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[s("code",[this._v("Promise.reject()")])]),this._v("：")]),this._v(" "),s("p",[this._v("Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"promise-的局限"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-的局限","aria-hidden":"true"}},[this._v("#")]),this._v(" Promise 的局限")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("错误被吃掉")])]),this._v(" "),s("p",[this._v("Promise 内部的错误不会影响到 Promise 外部的代码，所以 Promise 链中的错误很容易被忽略掉，这也是为什么一般会推荐在 Promise 链的最后添加一个 catch 函数，因为对于一个没有错误处理函数的 Promise 链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("单一值")])]),this._v(" "),s("p",[this._v("Promise 只能有一个完成值或一个拒绝原因，然而在真实使用的时候，往往需要传递多个值，一般做法都是构造一个对象或数组，然后再传递，then 中获得这个值后，又会进行取值赋值的操作，每次封装和解封都无疑让代码变得笨重。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("无法取消")])]),this._v(" "),s("p",[this._v("Promise 一旦新建它就会立即执行，无法中途取消。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("无法得知 pending 状态")])]),this._v(" "),s("p",[this._v("当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")])])])}],!1,null,null,null);s.default=n.exports}}]);