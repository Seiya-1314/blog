(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{171:function(t,s,a){t.exports=a.p+"assets/img/4.b6b71ec4.jpg"},172:function(t,s,a){t.exports=a.p+"assets/img/5.6ebf4264.jpg"},173:function(t,s,a){t.exports=a.p+"assets/img/6.98df8e70.jpg"},174:function(t,s,a){t.exports=a.p+"assets/img/7.3f70b4ad.jpg"},410:function(t,s,a){"use strict";a.r(s);var r=[function(){var t=this.$createElement,s=this._self._c||t;return s("h1",{attrs:{id:"数组：为什么很多编程语言中数组都从0开始编号？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组：为什么很多编程语言中数组都从0开始编号？","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组：为什么很多编程语言中数组都从0开始编号？")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[this._v("#")]),this._v(" 前言")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性表","aria-hidden":"true"}},[this._v("#")]),this._v(" 线性表")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("u",[s("strong",[this._v("线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。")])]),this._v(" 其实除了数组，链表、队列、栈等也是线性表结构。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("img",{attrs:{src:a(171),alt:""}})])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"非线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非线性表","aria-hidden":"true"}},[this._v("#")]),this._v(" 非线性表")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("u",[s("strong",[this._v("在非线性表中，数据之间并不是简单的前后关系。比如二叉树、堆、图等。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("img",{attrs:{src:a(172),alt:""}})])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"数组的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组的特点","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组的特点")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("连续的空间")])])]),this._v(" "),s("li",[s("p",[s("strong",[this._v("相同类型的数据")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"随机访问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#随机访问","aria-hidden":"true"}},[this._v("#")]),this._v(" 随机访问")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("img",{attrs:{src:a(173),alt:""}})])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" data_type_size\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("数组和链表的区别 ？")]),this._v(" "),s("p",[this._v("很多人都回答说：“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。")]),this._v(" "),s("p",[this._v("实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"低效的插入和删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低效的插入和删除","aria-hidden":"true"}},[this._v("#")]),this._v(" 低效的插入和删除")])},function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ul",[r("li",[r("p",[r("strong",[t._v("插入操作")])]),t._v(" "),r("p",[t._v("假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？")]),t._v(" "),r("br"),t._v(" "),r("p",[r("strong",[t._v("如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。")])]),t._v(" "),r("br"),t._v(" "),r("p",[t._v("如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。")]),t._v(" "),r("p",[t._v("但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。")]),t._v(" "),r("p",[r("img",{attrs:{src:a(174),alt:""}})]),t._v(" "),r("p",[t._v("利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)，这个处理思想在快排中也会用到。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("strong",[this._v("删除操作")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"警惕数组的访问越界问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#警惕数组的访问越界问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 警惕数组的访问越界问题")])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" argv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\tarr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello world\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"容器能否完全替代数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器能否完全替代数组","aria-hidden":"true"}},[this._v("#")]),this._v(" 容器能否完全替代数组")])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("tips")]),this._v(" "),s("p",[this._v("数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[this._v("注意：")]),this._v(" "),s("p",[this._v("扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"容器、数组的选择经验"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器、数组的选择经验","aria-hidden":"true"}},[this._v("#")]),this._v(" 容器、数组的选择经验")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"开篇解答"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开篇解答","aria-hidden":"true"}},[this._v("#")]),this._v(" 开篇解答")])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ul",[a("li",[a("p",[a("strong",[t._v("解答一")])]),t._v(" "),a("p",[t._v("从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" type_size\n")])])]),t._v(" "),a("br"),t._v(" "),a("p",[t._v("但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("type_size\n")])])]),a("p",[t._v("对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。")]),t._v(" "),a("br"),t._v(" "),a("p",[a("strong",[t._v("数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("ul",[s("li",[s("p",[s("strong",[this._v("解答二")])]),this._v(" "),s("p",[this._v("C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。")])])])}],e=a(0),n=Object(e.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),a("br"),t._v(" "),a("author",{attrs:{time:"2019年07月31日"}}),t._v(" "),a("br"),t._v(" "),t._m(1),t._v(" "),a("br"),t._v(" "),a("p",[t._v("在大部分编程语言中，数组都是从 0 开始编号的，但你是否下意识地想过，为什么数组要从 0 开始编号，而不是从 1 开始呢？ 从 1 开始不是更符合人类的思维习惯吗？")]),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),t._m(2),t._v(" "),a("br"),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[a("strong",[t._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")])])],1),t._v(" "),a("br"),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),a("br"),t._v(" "),a("br"),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),a("br"),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),a("p",[t._v("正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。")]),t._v(" "),a("br"),t._v(" "),t._m(11),t._v(" "),a("p",[t._v("数组是如何实现根据下标随机访问数组元素的？")]),t._v(" "),a("p",[t._v("我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10] 来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。")]),t._v(" "),t._m(12),t._v(" "),a("br"),t._v(" "),a("p",[t._v("计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：")]),t._v(" "),t._m(13),a("br"),t._v(" "),t._m(14),t._v(" "),a("br"),t._v(" "),t._m(15),t._v(" "),a("p",[t._v("现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？")]),t._v(" "),a("br"),t._v(" "),t._m(16),t._v(" "),a("br"),t._v(" "),a("ul",[a("li",[t._m(17),t._v(" "),a("p",[t._v("跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。")]),t._v(" "),a("br"),t._v(" "),a("p",[t._v("实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率会提高很多。")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[a("strong",[t._v("我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。")])])],1)])]),t._v(" "),a("br"),t._v(" "),t._m(18),t._v(" "),a("p",[t._v("首先，来分析一下这段 C 语言代码的运行结果：")]),t._v(" "),t._m(19),a("p",[t._v("这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3] 访问越界。")]),t._v(" "),a("p",[t._v("在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。")]),t._v(" "),a("br"),t._v(" "),t._m(20),t._v(" "),a("p",[t._v("针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？")]),t._v(" "),a("br"),t._v(" "),a("p",[t._v("ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。")]),t._v(" "),t._m(21),t._v(" "),a("br"),t._v(" "),t._m(22),t._v(" "),a("br"),t._v(" "),t._m(23),t._v(" "),a("p",[t._v("对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。")]),t._v(" "),a("br"),t._v(" "),t._m(24),t._v(" "),a("br"),t._v(" "),t._m(25),t._v(" "),a("br"),t._v(" "),t._m(26)],1)},r,!1,null,null,null);s.default=n.exports}}]);